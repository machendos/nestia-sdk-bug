"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NestiaSdkApplication = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const typescript_1 = __importDefault(require("typescript"));
const AccessorAnalyzer_1 = require("./analyses/AccessorAnalyzer");
const ConfigAnalyzer_1 = require("./analyses/ConfigAnalyzer");
const ControllerAnalyzer_1 = require("./analyses/ControllerAnalyzer");
const ReflectAnalyzer_1 = require("./analyses/ReflectAnalyzer");
const E2eGenerator_1 = require("./generates/E2eGenerator");
const SdkGenerator_1 = require("./generates/SdkGenerator");
const SwaggerGenerator_1 = require("./generates/SwaggerGenerator");
const MapUtil_1 = require("./utils/MapUtil");
class NestiaSdkApplication {
    constructor(config, compilerOptions) {
        this.config = config;
        this.compilerOptions = compilerOptions;
    }
    e2e() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.config.output)
                throw new Error("Error on NestiaApplication.e2e(): output path of SDK is not specified.");
            else if (!this.config.e2e)
                throw new Error("Error on NestiaApplication.e2e(): output path of e2e test files is not specified.");
            const validate = (title) => (location) => __awaiter(this, void 0, void 0, function* () {
                const parent = path_1.default.resolve(location + "/..");
                const stats = yield fs_1.default.promises.lstat(parent);
                if (stats.isDirectory() === false)
                    throw new Error(`Error on NestiaApplication.e2e(): output directory of ${title} does not exists.`);
            });
            yield validate("sdk")(this.config.output);
            yield validate("e2e")(this.config.e2e);
            print_title("Nestia E2E Generator");
            yield this.generate("e2e", (config) => config, (checker) => (config) => (routes) => __awaiter(this, void 0, void 0, function* () {
                yield SdkGenerator_1.SdkGenerator.generate(checker)(config)(routes);
                yield E2eGenerator_1.E2eGenerator.generate(config)(routes);
            }));
        });
    }
    sdk() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.config.output)
                throw new Error("Error on NestiaApplication.sdk(): output path is not specified.");
            const parent = path_1.default.resolve(this.config.output + "/..");
            const stats = yield fs_1.default.promises.lstat(parent);
            if (stats.isDirectory() === false)
                throw new Error("Error on NestiaApplication.sdk(): output directory does not exists.");
            print_title("Nestia SDK Generator");
            yield this.generate("sdk", (config) => config, SdkGenerator_1.SdkGenerator.generate);
        });
    }
    swagger() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!((_a = this.config.swagger) === null || _a === void 0 ? void 0 : _a.output))
                throw new Error(`Error on NestiaApplication.swagger(): output path of the "swagger.json" is not specified.`);
            const parsed = path_1.default.parse(this.config.swagger.output);
            const directory = !!parsed.ext
                ? path_1.default.resolve(parsed.dir)
                : this.config.swagger.output;
            const stats = yield fs_1.default.promises.lstat(directory);
            if (stats.isDirectory() === false)
                throw new Error("Error on NestiaApplication.swagger(): output directory does not exists.");
            print_title("Nestia Swagger Generator");
            yield this.generate("swagger", (config) => config.swagger, SwaggerGenerator_1.SwaggerGenerator.generate);
        });
    }
    generate(method, config, archiver) {
        return __awaiter(this, void 0, void 0, function* () {
            //----
            // ANALYZE REFLECTS
            //----
            const unique = new WeakSet();
            const controllers = [];
            const project = {
                config: this.config,
                input: yield ConfigAnalyzer_1.ConfigAnalyzer.input(this.config),
                checker: null,
                errors: [],
                warnings: [],
            };
            console.log("Analyzing reflections");
            for (const include of (yield ConfigAnalyzer_1.ConfigAnalyzer.input(this.config)).include)
                controllers.push(...(yield ReflectAnalyzer_1.ReflectAnalyzer.analyze(project)(unique, include.file, include.paths, include.controller)));
            const agg = (() => {
                const set = new Set();
                for (const c of controllers)
                    for (const cPath of c.paths)
                        for (const f of c.functions)
                            for (const fPath of f.paths)
                                set.add(`${f.method}::${cPath}/${fPath}`);
                return set.size;
            })();
            console.log(`  - controllers: #${controllers.length}`);
            console.log(`  - paths: #${agg}`);
            console.log(`  - routes: #${controllers
                .map((c) => c.paths.length *
                c.functions.map((f) => f.paths.length).reduce((a, b) => a + b, 0))
                .reduce((a, b) => a + b, 0)}`);
            //----
            // ANALYZE TYPESCRIPT CODE
            //----
            console.log("Analyzing source codes");
            const program = typescript_1.default.createProgram(controllers.map((c) => c.file), this.compilerOptions);
            project.checker = program.getTypeChecker();
            const routeList = [];
            for (const c of controllers) {
                const file = program.getSourceFile(c.file);
                if (file === undefined)
                    continue;
                routeList.push(...(yield ControllerAnalyzer_1.ControllerAnalyzer.analyze(project)(file, c)));
            }
            // REPORT ERRORS
            if (project.errors.length) {
                report_errors("error")(project.errors);
                process.exit(-1);
            }
            if (project.warnings.length)
                report_errors("warning")(project.warnings);
            // FIND IMPLICIT TYPES
            const implicit = routeList.filter(is_implicit_return_typed);
            if (implicit.length > 0)
                throw new Error(`NestiaApplication.${method}(): implicit return type is not allowed.\n` +
                    "\n" +
                    "List of implicit return typed routes:\n" +
                    implicit
                        .map((it) => `  - ${it.symbol.class}.${it.symbol.function} at "${it.location}"`)
                        .join("\n"));
            // DO GENERATE
            AccessorAnalyzer_1.AccessorAnalyzer.analyze(routeList);
            yield archiver(project.checker)(config(this.config))(routeList);
        });
    }
}
exports.NestiaSdkApplication = NestiaSdkApplication;
const print_title = (str) => {
    console.log("-----------------------------------------------------------");
    console.log(` ${str}`);
    console.log("-----------------------------------------------------------");
};
const is_implicit_return_typed = (route) => {
    const name = route.output.typeName;
    if (name === "void")
        return false;
    else if (name.indexOf("readonly [") !== -1)
        return true;
    const pos = name.indexOf("__object");
    if (pos === -1)
        return false;
    const before = pos - 1;
    const after = pos + "__object".length;
    for (const i of [before, after])
        if (name[i] === undefined)
            continue;
        else if (VARIABLE.test(name[i]))
            return false;
    return true;
};
const report_errors = (type) => (errors) => {
    // key: file
    // key: controller
    // key: function
    // value: message
    const map = new Map();
    for (const e of errors) {
        const file = MapUtil_1.MapUtil.take(map, e.file, () => new Map());
        const controller = MapUtil_1.MapUtil.take(file, e.controller, () => new Map());
        const func = MapUtil_1.MapUtil.take(controller, e.function, () => new Set());
        func.add(e.message);
    }
    console.log("");
    print_title(`Nestia ${type[0].toUpperCase()}${type.slice(1)} Report`);
    for (const [file, cMap] of map) {
        for (const [controller, fMap] of cMap)
            for (const [func, messages] of fMap) {
                const location = path_1.default.relative(process.cwd(), file);
                console.log(`${location} - ${func !== null ? `${controller}.${func}()` : controller}`);
                for (const msg of messages)
                    console.log(`  - ${msg}`);
                console.log("");
            }
    }
};
const VARIABLE = /[a-zA-Z_$0-9]/;
//# sourceMappingURL=NestiaSdkApplication.js.map