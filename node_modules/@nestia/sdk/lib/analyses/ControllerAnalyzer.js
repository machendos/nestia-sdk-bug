"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ControllerAnalyzer = void 0;
const path_1 = __importDefault(require("path"));
const HashMap_1 = require("tstl/container/HashMap");
const typescript_1 = __importDefault(require("typescript"));
const CommentFactory_1 = require("typia/lib/factories/CommentFactory");
const PathUtil_1 = require("../utils/PathUtil");
const ExceptionAnalyzer_1 = require("./ExceptionAnalyzer");
const GenericAnalyzer_1 = require("./GenericAnalyzer");
const ImportAnalyzer_1 = require("./ImportAnalyzer");
const PathAnalyzer_1 = require("./PathAnalyzer");
const SecurityAnalyzer_1 = require("./SecurityAnalyzer");
var ControllerAnalyzer;
(function (ControllerAnalyzer) {
    ControllerAnalyzer.analyze = (project) => (sourceFile, controller) => __awaiter(this, void 0, void 0, function* () {
        // FIND CONTROLLER CLASS
        const ret = [];
        typescript_1.default.forEachChild(sourceFile, (node) => {
            var _a;
            if (typescript_1.default.isClassDeclaration(node) &&
                ((_a = node.name) === null || _a === void 0 ? void 0 : _a.escapedText) === controller.name) {
                // ANALYZE THE CONTROLLER
                ret.push(..._Analyze_controller(project)(controller, node));
                return;
            }
        });
        return ret;
    });
    /* ---------------------------------------------------------
          CLASS
      --------------------------------------------------------- */
    const _Analyze_controller = (project) => (controller, classNode) => {
        const classType = project.checker.getTypeAtLocation(classNode);
        const genericDict = GenericAnalyzer_1.GenericAnalyzer.analyze(project.checker, classNode);
        const ret = [];
        for (const property of classType.getProperties()) {
            // GET METHOD DECLARATION
            const declaration = (property.declarations || [])[0];
            if (!declaration || !typescript_1.default.isMethodDeclaration(declaration))
                continue;
            // IDENTIFIER MUST BE
            const identifier = declaration.name;
            if (!typescript_1.default.isIdentifier(identifier))
                continue;
            // ANALYZED WITH THE REFLECTED-FUNCTION
            const runtime = controller.functions.find((f) => f.name === identifier.escapedText);
            if (runtime === undefined)
                continue;
            const routes = _Analyze_function(project)(controller, genericDict, runtime, declaration, property);
            ret.push(...routes);
        }
        return ret;
    };
    /* ---------------------------------------------------------
          FUNCTION
      --------------------------------------------------------- */
    const _Analyze_function = (project) => (controller, genericDict, func, declaration, symbol) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        // PREPARE ASSETS
        const type = project.checker.getTypeOfSymbolAtLocation(symbol, symbol.valueDeclaration);
        const signature = project.checker.getSignaturesOfType(type, typescript_1.default.SignatureKind.Call)[0];
        if (signature === undefined) {
            project.errors.push({
                file: controller.file,
                controller: controller.name,
                function: func.name,
                message: "unable to get the type signature.",
            });
            return [];
        }
        // SKIP @IGNORE TAG
        const jsDocTags = signature.getJsDocTags();
        if (jsDocTags.some((tag) => tag.name === "ignore"))
            return [];
        // EXPLORE CHILDREN TYPES
        const importDict = new HashMap_1.HashMap();
        const parameters = func.parameters.map((param) => _Analyze_parameter(project)(genericDict, importDict, controller, func.name, param, signature.getParameters()[param.index]));
        const outputType = ImportAnalyzer_1.ImportAnalyzer.analyze(project.checker, genericDict, importDict, signature.getReturnType());
        if (outputType === null || outputType.typeName === "__type") {
            project.errors.push({
                file: controller.file,
                controller: controller.name,
                function: func.name,
                message: "implicit (unnamed) return type.",
            });
            return [];
        }
        else if (func.method === "HEAD" &&
            outputType.typeName !== "void" &&
            outputType.typeName !== "undefined") {
            project.errors.push({
                file: controller.file,
                controller: controller.name,
                function: func.name,
                message: `HEAD method must return void type.`,
            });
            return [];
        }
        const exceptions = ExceptionAnalyzer_1.ExceptionAnalyzer.analyze(project)(genericDict, project.config.propagate === true ? importDict : new HashMap_1.HashMap())(controller, func)(declaration);
        const imports = importDict
            .toJSON()
            .map((pair) => [pair.first, pair.second.toJSON()]);
        // CONSIDER SECURITY TAGS
        const security = SecurityAnalyzer_1.SecurityAnalyzer.merge(...controller.security, ...func.security, ...jsDocTags
            .filter((tag) => tag.name === "security")
            .map((tag) => {
            var _a;
            return ((_a = tag.text) !== null && _a !== void 0 ? _a : []).map((text) => {
                const line = text.text
                    .split(" ")
                    .filter((s) => s.trim())
                    .filter((s) => !!s.length);
                if (line.length === 0)
                    return {};
                return {
                    [line[0]]: line.slice(1),
                };
            });
        })
            .flat());
        // CONSTRUCT COMMON DATA
        const common = Object.assign(Object.assign({}, func), { parameters: parameters.filter((p) => p !== null), output: {
                type: outputType.type,
                typeName: outputType.typeName,
                contentType: func.contentType,
            }, imports, status: func.status, symbol: {
                class: controller.name,
                function: func.name,
            }, location: (() => {
                const file = declaration.getSourceFile();
                const { line, character } = file.getLineAndCharacterOfPosition(declaration.pos);
                return `${path_1.default.relative(process.cwd(), file.fileName)}:${line + 1}:${character + 1}`;
            })(), description: CommentFactory_1.CommentFactory.description(symbol), operationId: (_b = (_a = jsDocTags
                .find(({ name }) => name === "operationId")) === null || _a === void 0 ? void 0 : _a.text) === null || _b === void 0 ? void 0 : _b[0].text.split(" ")[0].trim(), jsDocTags: jsDocTags, setHeaders: jsDocTags
                .filter((t) => {
                var _a;
                return ((_a = t.text) === null || _a === void 0 ? void 0 : _a.length) &&
                    t.text[0].text &&
                    (t.name === "setHeader" || t.name === "assignHeaders");
            })
                .map((t) => {
                var _a;
                return t.name === "setHeader"
                    ? {
                        type: "setter",
                        source: t.text[0].text.split(" ")[0].trim(),
                        target: (_a = t.text[0].text.split(" ")[1]) === null || _a === void 0 ? void 0 : _a.trim(),
                    }
                    : {
                        type: "assigner",
                        source: t.text[0].text,
                    };
            }), security,
            exceptions });
        // CONFIGURE PATHS
        const pathList = new Set();
        const versions = _Analyze_versions(project.input.versioning === undefined
            ? undefined
            : (_j = (_d = (_c = func.versions) !== null && _c !== void 0 ? _c : controller.versions) !== null && _d !== void 0 ? _d : (((_e = project.input.versioning) === null || _e === void 0 ? void 0 : _e.defaultVersion) !== undefined
                ? Array.isArray((_f = project.input.versioning) === null || _f === void 0 ? void 0 : _f.defaultVersion)
                    ? (_g = project.input.versioning) === null || _g === void 0 ? void 0 : _g.defaultVersion
                    : [(_h = project.input.versioning) === null || _h === void 0 ? void 0 : _h.defaultVersion]
                : undefined)) !== null && _j !== void 0 ? _j : undefined);
        for (const prefix of controller.prefixes)
            for (const cPath of controller.paths)
                for (const filePath of func.paths)
                    pathList.add(PathAnalyzer_1.PathAnalyzer.join(prefix, cPath, filePath));
        return [...pathList]
            .map((individual) => PathAnalyzer_1.PathAnalyzer.combinate(project.input.globalPrefix)([...versions].map((v) => {
            var _a, _b;
            return v === null
                ? null
                : ((_b = (_a = project.input.versioning) === null || _a === void 0 ? void 0 : _a.prefix) === null || _b === void 0 ? void 0 : _b.length)
                    ? `${project.input.versioning.prefix}${v}`
                    : v;
        }))({
            method: func.method,
            path: individual,
        }))
            .flat()
            .filter((path) => {
            const escaped = PathAnalyzer_1.PathAnalyzer.escape(path);
            if (escaped === null)
                project.errors.push({
                    file: controller.file,
                    controller: controller.name,
                    function: func.name,
                    message: `unable to escape the path "${path}".`,
                });
            return escaped !== null;
        })
            .map((path) => (Object.assign(Object.assign({}, common), { path: PathAnalyzer_1.PathAnalyzer.escape(path), accessors: [...PathUtil_1.PathUtil.accessors(path), func.name] })));
    };
    const _Analyze_parameter = (project) => (genericDict, importDict, controller, funcName, param, symbol) => {
        var _a;
        const type = project.checker.getTypeOfSymbolAtLocation(symbol, symbol.valueDeclaration);
        const name = symbol.getEscapedName().toString();
        const optional = !!((_a = project.checker.symbolToParameterDeclaration(symbol, undefined, undefined)) === null || _a === void 0 ? void 0 : _a.questionToken);
        const errors = [];
        // DO NOT SUPPORT BODY PARAMETER
        if (param.category === "body" && param.field !== undefined)
            errors.push({
                file: controller.file,
                controller: controller.name,
                function: funcName,
                message: `nestia does not support body field specification. ` +
                    `Therefore, erase the "${name}" parameter and ` +
                    `re-define a new body decorator accepting full structured message.`,
            });
        if (optional === true && param.category !== "query")
            errors.push({
                file: controller.file,
                controller: controller.name,
                function: funcName,
                message: `nestia does not support optional parameter except query parameter. ` +
                    `Therefore, erase question mark on the "${name}" parameter, ` +
                    `or re-define a new method without the "${name}" parameter.`,
            });
        if (optional === true &&
            param.category === "query" &&
            param.field === undefined)
            errors.push({
                file: controller.file,
                controller: controller.name,
                function: funcName,
                message: `nestia does not support optional query parameter without field specification. ` +
                    `Therefore, erase question mark on the "${name}" parameter, ` +
                    `or re-define re-define parameters for each query parameters.`,
            });
        // GET TYPE NAME
        const tuple = ImportAnalyzer_1.ImportAnalyzer.analyze(project.checker, genericDict, importDict, type);
        if (tuple === null || tuple.typeName === "__type")
            errors.push({
                file: controller.file,
                controller: controller.name,
                function: funcName,
                message: `implicit (unnamed) parameter type from "${name}".`,
            });
        if (errors.length) {
            project.errors.push(...errors);
            return null;
        }
        return Object.assign(Object.assign({}, param), { name,
            optional, type: tuple.type, typeName: tuple.typeName });
    };
    function _Analyze_versions(value) {
        if (value === undefined)
            return [null];
        return value.map((v) => (typeof v === "symbol" ? null : v));
    }
})(ControllerAnalyzer || (exports.ControllerAnalyzer = ControllerAnalyzer = {}));
//# sourceMappingURL=ControllerAnalyzer.js.map