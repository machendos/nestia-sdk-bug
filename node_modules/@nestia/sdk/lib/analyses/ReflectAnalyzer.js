"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReflectAnalyzer = void 0;
const Constants = __importStar(require("@nestjs/common/constants"));
require("reflect-metadata");
const module_1 = require("tstl/ranges/module");
const ArrayUtil_1 = require("../utils/ArrayUtil");
const PathAnalyzer_1 = require("./PathAnalyzer");
const SecurityAnalyzer_1 = require("./SecurityAnalyzer");
var ReflectAnalyzer;
(function (ReflectAnalyzer) {
    ReflectAnalyzer.analyze = (project) => (unique, file, prefixes, target) => __awaiter(this, void 0, void 0, function* () {
        const module = yield (() => __awaiter(this, void 0, void 0, function* () {
            try {
                return yield Promise.resolve(`${file}`).then(s => __importStar(require(s)));
            }
            catch (exp) {
                console.log(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                console.log(`Error on "${file}" file. Check your code.`);
                console.log(exp);
                console.log(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");
                process.exit(-1);
            }
        }))();
        const ret = [];
        for (const [key, value] of Object.entries(module)) {
            if (typeof value !== "function" || unique.has(value))
                continue;
            else if ((target !== null && target !== void 0 ? target : value) !== value)
                continue;
            else
                unique.add(value);
            const result = _Analyze_controller(project)(file, key, value, prefixes);
            if (result !== null)
                ret.push(result);
        }
        return ret;
    });
    /* ---------------------------------------------------------
          CONTROLLER
      --------------------------------------------------------- */
    const _Analyze_controller = (project) => (file, name, creator, prefixes) => {
        var _a;
        //----
        // VALIDATIONS
        //----
        // MUST BE TYPE OF A CREATOR WHO HAS THE CONSTRUCTOR
        if (!(creator instanceof Function && creator.constructor instanceof Function))
            return null;
        // MUST HAVE THOSE MATADATA
        else if (ArrayUtil_1.ArrayUtil.has(Reflect.getMetadataKeys(creator), Constants.PATH_METADATA, Constants.HOST_METADATA, Constants.SCOPE_OPTIONS_METADATA) === false)
            return null;
        //----
        // CONSTRUCTION
        //----
        // BASIC INFO
        const meta = {
            file,
            name,
            functions: [],
            prefixes,
            paths: _Get_paths(creator).filter((str) => {
                if (str.includes("*") === true) {
                    project.warnings.push({
                        file,
                        controller: name,
                        function: null,
                        message: "@nestia/sdk does not compose wildcard controller.",
                    });
                    return false;
                }
                return true;
            }),
            versions: _Get_versions(creator),
            security: _Get_securities(creator),
            swaggerTgas: (_a = Reflect.getMetadata("swagger/apiUseTags", creator)) !== null && _a !== void 0 ? _a : [],
        };
        // PARSE CHILDREN DATA
        for (const tuple of _Get_prototype_entries(creator)) {
            const child = _Analyze_function(project)(creator.prototype, meta, ...tuple);
            if (child !== null)
                meta.functions.push(child);
        }
        // RETURNS
        return meta;
    };
    function _Get_prototype_entries(creator) {
        const keyList = Object.getOwnPropertyNames(creator.prototype);
        const entries = keyList.map((key) => [
            key,
            creator.prototype[key],
        ]);
        const parent = Object.getPrototypeOf(creator);
        if (parent.prototype !== undefined)
            entries.push(..._Get_prototype_entries(parent));
        return entries;
    }
    function _Get_paths(target) {
        const value = Reflect.getMetadata(Constants.PATH_METADATA, target);
        if (typeof value === "string")
            return [value];
        else if (value.length === 0)
            return [""];
        else
            return value;
    }
    function _Get_versions(target) {
        const value = Reflect.getMetadata(Constants.VERSION_METADATA, target);
        return value === undefined || Array.isArray(value) ? value : [value];
    }
    function _Get_securities(value) {
        const entire = Reflect.getMetadata("swagger/apiSecurity", value);
        return entire ? SecurityAnalyzer_1.SecurityAnalyzer.merge(...entire) : [];
    }
    function _Get_exceptions(value) {
        const entire = Reflect.getMetadata("nestia/TypedException", value);
        return Object.fromEntries((entire !== null && entire !== void 0 ? entire : []).map((exp) => [exp.status, exp]));
    }
    /* ---------------------------------------------------------
          FUNCTION
      --------------------------------------------------------- */
    const _Analyze_function = (project) => (classProto, controller, name, proto) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        //----
        // VALIDATIONS
        //----
        // MUST BE TYPE OF A FUNCTION
        if (!(proto instanceof Function))
            return null;
        // MUST HAVE THOSE METADATE
        else if (ArrayUtil_1.ArrayUtil.has(Reflect.getMetadataKeys(proto), Constants.PATH_METADATA, Constants.METHOD_METADATA) === false)
            return null;
        const errors = [];
        //----
        // CONSTRUCTION
        //----
        // BASIC INFO
        const encrypted = ((_c = (_b = (_a = Reflect.getMetadata(Constants.INTERCEPTORS_METADATA, proto)) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.constructor) === null || _c === void 0 ? void 0 : _c.name) === "EncryptedRouteInterceptor";
        const query = ((_f = (_e = (_d = Reflect.getMetadata(Constants.INTERCEPTORS_METADATA, proto)) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.constructor) === null || _f === void 0 ? void 0 : _f.name) === "TypedQueryRouteInterceptor";
        const method = METHODS[Reflect.getMetadata(Constants.METHOD_METADATA, proto)];
        if (method === undefined || method === "OPTIONS")
            return null;
        const parameters = (() => {
            const nestParameters = Reflect.getMetadata(Constants.ROUTE_ARGS_METADATA, classProto.constructor, name);
            if (nestParameters === undefined)
                return [];
            const output = [];
            for (const tuple of Object.entries(nestParameters)) {
                const child = _Analyze_parameter(...tuple);
                if (child !== null)
                    output.push(child);
            }
            return output.sort((x, y) => x.index - y.index);
        })();
        // VALIDATE BODY
        const body = parameters.find((param) => param.category === "body");
        if (body !== undefined && (method === "GET" || method === "HEAD")) {
            project.errors.push({
                file: controller.file,
                controller: controller.name,
                function: name,
                message: `"body" parameter cannot be used in the "${method}" method.`,
            });
            return null;
        }
        // DO CONSTRUCT
        const meta = {
            name,
            method: method === "ALL" ? "POST" : method,
            paths: _Get_paths(proto).filter((str) => {
                if (str.includes("*") === true) {
                    project.warnings.push({
                        file: controller.file,
                        controller: controller.name,
                        function: name,
                        message: "@nestia/sdk does not compose wildcard method.",
                    });
                    return false;
                }
                return true;
            }),
            versions: _Get_versions(proto),
            parameters,
            status: Reflect.getMetadata(Constants.HTTP_CODE_METADATA, proto),
            encrypted,
            contentType: encrypted
                ? "text/plain"
                : query
                    ? "application/x-www-form-urlencoded"
                    : (_j = (_h = (_g = Reflect.getMetadata(Constants.HEADERS_METADATA, proto)) === null || _g === void 0 ? void 0 : _g.find((h) => typeof (h === null || h === void 0 ? void 0 : h.name) === "string" &&
                        typeof (h === null || h === void 0 ? void 0 : h.value) === "string" &&
                        h.name.toLowerCase() === "content-type")) === null || _h === void 0 ? void 0 : _h.value) !== null && _j !== void 0 ? _j : "application/json",
            security: _Get_securities(proto),
            exceptions: _Get_exceptions(proto),
            swaggerTags: [
                ...new Set([
                    ...controller.swaggerTgas,
                    ...((_k = Reflect.getMetadata("swagger/apiUseTags", proto)) !== null && _k !== void 0 ? _k : []),
                ]),
            ],
        };
        // VALIDATE PATH ARGUMENTS
        for (const controllerLocation of controller.paths)
            for (const metaLocation of meta.paths) {
                // NORMALIZE LOCATION
                const location = PathAnalyzer_1.PathAnalyzer.join(controllerLocation, metaLocation);
                if (location.includes("*"))
                    continue;
                // LIST UP PARAMETERS
                const binded = PathAnalyzer_1.PathAnalyzer.parameters(location);
                if (binded === null) {
                    project.errors.push({
                        file: controller.file,
                        controller: controller.name,
                        function: name,
                        message: `invalid path ("${location}")`,
                    });
                    continue;
                }
                const parameters = meta.parameters
                    .filter((param) => param.category === "param")
                    .map((param) => param.field)
                    .sort();
                // DO VALIDATE
                if ((0, module_1.equal)(binded.sort(), parameters) === false)
                    errors.push({
                        file: controller.file,
                        controller: controller.name,
                        function: name,
                        message: `binded arguments in the "path" between function's decorator and parameters' decorators are different (function: [${binded.join(", ")}], parameters: [${parameters.join(", ")}]).`,
                    });
            }
        // RETURNS
        if (errors.length) {
            project.errors.push(...errors);
            return null;
        }
        return meta;
    };
    /* ---------------------------------------------------------
          PARAMETER
      --------------------------------------------------------- */
    function _Analyze_parameter(key, param) {
        const symbol = key.split(":")[0];
        if (symbol.indexOf("__custom") !== -1)
            return _Analyze_custom_parameter(param);
        const typeIndex = Number(symbol[0]);
        if (isNaN(typeIndex) === true)
            return null;
        const type = NEST_PARAMETER_TYPES[typeIndex];
        if (type === undefined)
            return null;
        return {
            custom: false,
            name: key,
            category: type,
            index: param.index,
            field: param.data,
        };
    }
    function _Analyze_custom_parameter(param) {
        if (param.factory === undefined)
            return null;
        else if (param.factory.name === "EncryptedBody" ||
            param.factory.name === "PlainBody" ||
            param.factory.name === "TypedQueryBody" ||
            param.factory.name === "TypedBody")
            return {
                custom: true,
                category: "body",
                index: param.index,
                name: param.name,
                field: param.data,
                encrypted: param.factory.name === "EncryptedBody",
                contentType: param.factory.name === "PlainBody" ||
                    param.factory.name === "EncryptedBody"
                    ? "text/plain"
                    : param.factory.name === "TypedQueryBody"
                        ? "application/x-www-form-urlencoded"
                        : "application/json",
            };
        else if (param.factory.name === "TypedHeaders")
            return {
                custom: true,
                category: "headers",
                name: param.name,
                index: param.index,
                field: param.data,
            };
        else if (param.factory.name === "TypedParam")
            return {
                custom: true,
                category: "param",
                name: param.name,
                index: param.index,
                field: param.data,
            };
        else if (param.factory.name === "TypedQuery")
            return {
                custom: true,
                name: param.name,
                category: "query",
                index: param.index,
                field: undefined,
            };
        else
            return null;
    }
})(ReflectAnalyzer || (exports.ReflectAnalyzer = ReflectAnalyzer = {}));
// node_modules/@nestjs/common/lib/enums/request-method.enum.ts
const METHODS = [
    "GET",
    "POST",
    "PUT",
    "DELETE",
    "PATCH",
    "ALL",
    "OPTIONS",
    "HEAD",
];
// node_modules/@nestjs/common/lib/route-paramtypes.enum.ts
const NEST_PARAMETER_TYPES = [
    undefined,
    undefined,
    undefined,
    "body",
    "query",
    "param",
    "headers",
    undefined,
    undefined,
    undefined,
    undefined,
    undefined,
];
//# sourceMappingURL=ReflectAnalyzer.js.map