"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PathAnalyzer = void 0;
const common_1 = require("@nestjs/common");
const path_1 = __importDefault(require("path"));
const path_to_regexp_1 = require("path-to-regexp");
var PathAnalyzer;
(function (PathAnalyzer) {
    PathAnalyzer.combinate = (globalPrefix) => (versions) => (props) => {
        var _a;
        const out = (str) => versions.map((v) => (v === null ? str : PathAnalyzer.join(v, str)));
        if (!(globalPrefix === null || globalPrefix === void 0 ? void 0 : globalPrefix.prefix.length))
            return out(props.path);
        else if (!((_a = globalPrefix.exclude) === null || _a === void 0 ? void 0 : _a.length))
            return out(props.path).map((str) => PathAnalyzer.join(globalPrefix.prefix, str));
        return globalPrefix.exclude.some((exclude) => typeof exclude === "string"
            ? RegExp(exclude).test(props.path)
            : METHOD(exclude.method) === props.method &&
                RegExp(exclude.path).test(props.path))
            ? out(props.path)
            : out(props.path).map((str) => PathAnalyzer.join(globalPrefix.prefix, str));
    };
    PathAnalyzer.join = (...args) => "/" +
        _Trim(path_1.default
            .join(...args.filter((s) => !!s.length))
            .split("\\")
            .join("/"));
    PathAnalyzer.escape = (str) => {
        const args = _Parse(str);
        if (args === null)
            return null;
        return ("/" +
            args
                .map((arg) => (arg.type === "param" ? `:${arg.value}` : arg.value))
                .join("/"));
    };
    PathAnalyzer.parameters = (str) => {
        const args = _Parse(str);
        if (args === null)
            return null;
        return args.filter((arg) => arg.type === "param").map((arg) => arg.value);
    };
    function _Parse(str) {
        const tokens = (() => {
            try {
                return (0, path_to_regexp_1.parse)(path_1.default.join(str).split("\\").join("/"));
            }
            catch (_a) {
                return null;
            }
        })();
        if (tokens === null)
            return null;
        const output = [];
        for (const key of tokens) {
            if (typeof key === "string")
                output.push({
                    type: "path",
                    value: _Trim(key),
                });
            else if (typeof key.name === "number" || _Trim(key.name) === "")
                return null;
            else
                output.push({
                    type: "param",
                    value: _Trim(key.name),
                });
        }
        return output;
    }
    function _Trim(str) {
        if (str[0] === "/")
            str = str.substring(1);
        if (str[str.length - 1] === "/")
            str = str.substring(0, str.length - 1);
        return str;
    }
})(PathAnalyzer || (exports.PathAnalyzer = PathAnalyzer = {}));
const METHOD = (value) => value === common_1.RequestMethod.ALL
    ? "all"
    : value === common_1.RequestMethod.DELETE
        ? "delete"
        : value === common_1.RequestMethod.GET
            ? "get"
            : value === common_1.RequestMethod.HEAD
                ? "head"
                : value === common_1.RequestMethod.OPTIONS
                    ? "options"
                    : value === common_1.RequestMethod.PATCH
                        ? "patch"
                        : value === common_1.RequestMethod.POST
                            ? "post"
                            : value === common_1.RequestMethod.PUT
                                ? "put"
                                : "unknown";
//# sourceMappingURL=PathAnalyzer.js.map