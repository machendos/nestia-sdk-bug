"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigAnalyzer = void 0;
const common_1 = require("@nestjs/common");
const constants_1 = require("@nestjs/common/constants");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const tstl_1 = require("tstl");
const SdkGenerator_1 = require("../generates/SdkGenerator");
const ArrayUtil_1 = require("../utils/ArrayUtil");
const MapUtil_1 = require("../utils/MapUtil");
const SourceFinder_1 = require("../utils/SourceFinder");
var ConfigAnalyzer;
(function (ConfigAnalyzer) {
    ConfigAnalyzer.input = (config) => MapUtil_1.MapUtil.take(memory, config, () => __awaiter(this, void 0, void 0, function* () {
        const input = config.input;
        if (Array.isArray(input))
            return transform_input(config)(input);
        else if (typeof input === "function")
            return analyze_application(yield input());
        else if (typeof input === "object")
            if (input === null)
                throw new Error("Invalid input config. It can't be null.");
            else
                return transform_input(config)(input.include, input.exclude);
        else if (typeof input === "string")
            return transform_input(config)([input]);
        else
            throw new Error("Invalid input config.");
    }));
    const analyze_application = (app) => __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const files = new tstl_1.HashMap();
        const container = app.container;
        const modules = [...container.getModules().values()].filter((m) => !!m.controllers.size);
        for (const m of modules) {
            const path = (_b = (_a = Reflect.getMetadata(constants_1.MODULE_PATH + container.getModules().applicationId, m.metatype)) !== null && _a !== void 0 ? _a : Reflect.getMetadata(constants_1.MODULE_PATH, m.metatype)) !== null && _b !== void 0 ? _b : "";
            for (const controller of [...m.controllers.keys()]) {
                const file = (_d = (_c = (yield require("get-function-location")(controller))) === null || _c === void 0 ? void 0 : _c.source) !== null && _d !== void 0 ? _d : null;
                if (file === null)
                    continue;
                const location = normalize_file(file);
                if (location.length === 0)
                    continue;
                const key = new tstl_1.Pair(controller, location);
                files.take(key, () => new Set([])).add(path);
            }
        }
        const versioning = (_e = app.config) === null || _e === void 0 ? void 0 : _e.versioningOptions;
        return {
            include: files.toJSON().map((pair) => ({
                controller: pair.first.first,
                file: pair.first.second,
                paths: [...pair.second.values()],
            })),
            globalPrefix: typeof ((_f = app.config) === null || _f === void 0 ? void 0 : _f.globalPrefix) === "string"
                ? {
                    prefix: app.config.globalPrefix,
                    exclude: (_h = (_g = app.config.globalPrefixOptions) === null || _g === void 0 ? void 0 : _g.exclude) !== null && _h !== void 0 ? _h : {},
                }
                : undefined,
            versioning: versioning === undefined || versioning.type !== common_1.VersioningType.URI
                ? undefined
                : {
                    prefix: versioning.prefix === undefined || versioning.prefix === false
                        ? "v"
                        : versioning.prefix,
                    defaultVersion: versioning.defaultVersion,
                },
        };
    });
    const normalize_file = (str) => str.substring(str.startsWith("file:///")
        ? process.cwd()[0] === "/"
            ? 7
            : 8
        : str.startsWith("file://")
            ? 7
            : 0);
    const transform_input = (config) => (include, exclude) => __awaiter(this, void 0, void 0, function* () {
        return ({
            include: (yield SourceFinder_1.SourceFinder.find({
                include,
                exclude,
                filter: filter(config),
            })).map((file) => ({
                paths: [""],
                file,
            })),
        });
    });
    const filter = (config) => (location) => __awaiter(this, void 0, void 0, function* () {
        return location.endsWith(".ts") &&
            !location.endsWith(".d.ts") &&
            (config.output === undefined ||
                (location.indexOf(path_1.default.join(config.output, "functional")) === -1 &&
                    (yield (yield bundler.get(config.output))(location))) === false);
    });
})(ConfigAnalyzer || (exports.ConfigAnalyzer = ConfigAnalyzer = {}));
const memory = new Map();
const bundler = new tstl_1.Singleton((output) => __awaiter(void 0, void 0, void 0, function* () {
    const assets = yield fs_1.default.promises.readdir(SdkGenerator_1.SdkGenerator.BUNDLE_PATH);
    const tuples = yield ArrayUtil_1.ArrayUtil.asyncMap(assets, (file) => __awaiter(void 0, void 0, void 0, function* () {
        const relative = path_1.default.join(output, file);
        const location = path_1.default.join(SdkGenerator_1.SdkGenerator.BUNDLE_PATH, file);
        const stats = yield fs_1.default.promises.stat(location);
        return new tstl_1.Pair(relative, stats.isDirectory());
    }));
    return (file) => __awaiter(void 0, void 0, void 0, function* () {
        for (const it of tuples)
            if (it.second === false && file === it.first)
                return true;
            else if (it.second === true && file.indexOf(it.first) === 0)
                return true;
        return false;
    });
}));
//# sourceMappingURL=ConfigAnalyzer.js.map